"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNativeToken = exports.ApproveGatewayError = exports.QueryTransferStatus = exports.GasToken = exports.CosmosChain = exports.EvmChain = exports.Environment = void 0;
var Environment;
(function (Environment) {
    Environment["DEVNET"] = "devnet";
    Environment["TESTNET"] = "testnet";
    Environment["MAINNET"] = "mainnet";
})(Environment = exports.Environment || (exports.Environment = {}));
var EvmChain;
(function (EvmChain) {
    EvmChain["ETHEREUM"] = "ethereum";
    EvmChain["AVALANCHE"] = "avalanche";
    EvmChain["FANTOM"] = "fantom";
    EvmChain["POLYGON"] = "polygon";
    EvmChain["MOONBEAM"] = "moonbeam";
    EvmChain["AURORA"] = "aurora";
    EvmChain["BINANCE"] = "binance";
    EvmChain["BNBCHAIN"] = "binance";
    EvmChain["ARBITRUM"] = "arbitrum";
    EvmChain["CELO"] = "celo";
    EvmChain["KAVA"] = "kava";
    EvmChain["BASE"] = "base";
})(EvmChain = exports.EvmChain || (exports.EvmChain = {}));
var CosmosChain;
(function (CosmosChain) {
    CosmosChain["AXELAR"] = "axelar";
    CosmosChain["COSMOSHUB"] = "cosmoshub";
    CosmosChain["JUNO"] = "juno";
    CosmosChain["OSMOSIS"] = "osmosis";
    CosmosChain["TERRA"] = "terra";
})(CosmosChain = exports.CosmosChain || (exports.CosmosChain = {}));
// Includes all native tokens and stablecoins
var GasToken;
(function (GasToken) {
    GasToken["ETH"] = "ETH";
    GasToken["AVAX"] = "AVAX";
    GasToken["GLMR"] = "GLMR";
    GasToken["FTM"] = "FTM";
    GasToken["MATIC"] = "MATIC";
    GasToken["UST"] = "UST";
    GasToken["USDC"] = "USDC";
    GasToken["AURORA"] = "aETH";
    GasToken["BINANCE"] = "BNB";
    GasToken["BNBCHAIN"] = "BNB";
    GasToken["CELO"] = "CELO";
    GasToken["KAVA"] = "KAVA";
    GasToken["BASE"] = "ETH";
})(GasToken = exports.GasToken || (exports.GasToken = {}));
var QueryTransferStatus;
(function (QueryTransferStatus) {
    QueryTransferStatus["DEPOSIT_CONFIRMED"] = "deposit_confirmed";
    QueryTransferStatus["ASSET_SENT"] = "asset_sent";
    QueryTransferStatus["VOTED"] = "voted";
    QueryTransferStatus["BATCH_SIGNED"] = "batch_signed";
    QueryTransferStatus["IBC_SENT"] = "ibc_sent";
    QueryTransferStatus["EXECUTED"] = "executed";
})(QueryTransferStatus = exports.QueryTransferStatus || (exports.QueryTransferStatus = {}));
var ApproveGatewayError;
(function (ApproveGatewayError) {
    ApproveGatewayError["ALREADY_APPROVED"] = "already approved";
    ApproveGatewayError["ALREADY_EXECUTED"] = "already executed";
    ApproveGatewayError["SIGN_COMMAND_FAILED"] = "cannot sign command";
    ApproveGatewayError["CONFIRM_COMMAND_FAILED"] = "cannot confirm command";
    ApproveGatewayError["FETCHING_STATUS_FAILED"] = "cannot fetching status";
    ApproveGatewayError["ERROR_BATCHED_COMMAND"] = "cannot find batch command";
    ApproveGatewayError["ERROR_GET_EVM_EVENT"] = "cannot get evm event";
    ApproveGatewayError["ERROR_BROADCAST_EVENT"] = "cannot broadcast event to destination chain";
    ApproveGatewayError["ERROR_UNKNOWN"] = "unknown error";
    ApproveGatewayError["ERROR_ACCOUNT_SEQUENCE_MISMATCH"] = "account sequence mismatch";
})(ApproveGatewayError = exports.ApproveGatewayError || (exports.ApproveGatewayError = {}));
const isNativeToken = (chain, selectedToken) => {
    var _a;
    const nativeTokenMap = {
        ethereum: GasToken.ETH,
        avalanche: GasToken.AVAX,
        fantom: GasToken.FTM,
        polygon: GasToken.MATIC,
        moonbeam: GasToken.GLMR,
        aurora: GasToken.AURORA,
        binance: GasToken.BINANCE,
        bnbchain: GasToken.BINANCE,
        celo: GasToken.CELO,
        kava: GasToken.KAVA,
        base: GasToken.BASE,
    };
    return ((_a = nativeTokenMap[chain]) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.toLowerCase());
};
exports.isNativeToken = isNativeToken;
//# sourceMappingURL=index.js.map