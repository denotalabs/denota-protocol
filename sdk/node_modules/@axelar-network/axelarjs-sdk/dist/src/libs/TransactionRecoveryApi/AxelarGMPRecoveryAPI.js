"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarGMPRecoveryAPI = exports.GMPErrorResponse = exports.GMPErrorMap = void 0;
const types_1 = require("../types");
const AxelarRecoveryApi_1 = require("./AxelarRecoveryApi");
const EVMClient_1 = __importDefault(require("./client/EVMClient"));
const IAxelarExecutable_1 = __importDefault(require("../abi/IAxelarExecutable"));
const ethers_1 = require("ethers");
const contract_1 = require("./constants/contract");
const AxelarQueryAPI_1 = require("../AxelarQueryAPI");
const chain_1 = __importDefault(require("./constants/chain"));
const contractEventHelper_1 = require("./helpers/contractEventHelper");
const erc20Abi_json_1 = __importDefault(require("../abi/erc20Abi.json"));
const AxelarGateway_1 = require("../AxelarGateway");
const providerHelper_1 = require("./helpers/providerHelper");
const error_1 = require("./constants/error");
const helpers_1 = require("./helpers");
const utils_1 = require("../../utils");
const types_2 = require("@axelar-network/axelarjs-types/axelar/evm/v1beta1/types");
const utils_2 = require("ethers/lib/utils");
exports.GMPErrorMap = {
    [AxelarRecoveryApi_1.GMPStatus.CANNOT_FETCH_STATUS]: types_1.ApproveGatewayError.FETCHING_STATUS_FAILED,
    [AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED]: types_1.ApproveGatewayError.ALREADY_EXECUTED,
    [AxelarRecoveryApi_1.GMPStatus.DEST_GATEWAY_APPROVED]: types_1.ApproveGatewayError.ALREADY_APPROVED,
};
const GMPErrorResponse = (error, errorDetails) => ({
    success: false,
    error: errorDetails || error,
});
exports.GMPErrorResponse = GMPErrorResponse;
class AxelarGMPRecoveryAPI extends AxelarRecoveryApi_1.AxelarRecoveryApi {
    constructor(config) {
        super(config);
        this.axelarQueryApi = new AxelarQueryAPI_1.AxelarQueryAPI({
            environment: config.environment,
            axelarRpcUrl: this.axelarRpcUrl,
            axelarLcdUrl: this.axelarLcdUrl,
        });
    }
    saveGMP(sourceTransactionHash, relayerAddress, transactionHash, error) {
        const _super = Object.create(null, {
            getAxelarGMPApiUrl: { get: () => super.getAxelarGMPApiUrl }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.execPost(_super.getAxelarGMPApiUrl, "", {
                method: "saveGMP",
                sourceTransactionHash,
                transactionHash,
                relayerAddress,
                error,
            });
        });
    }
    getCidFromSrcTxHash(destChainId, txHash, eventIndex) {
        return (0, helpers_1.getCommandId)(destChainId, txHash, eventIndex, this.environment, chain_1.default);
    }
    doesTxMeetConfirmHt(chain, currHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.axelarQueryApi
                .getConfirmationHeight(chain)
                .then((res) => res.height.greaterThan(currHeight))
                .catch(() => undefined);
        });
    }
    isEVMEventFailed(eventResponse) {
        var _a;
        if (!eventResponse)
            return undefined;
        return [types_2.Event_Status.STATUS_FAILED, types_2.Event_Status.STATUS_UNSPECIFIED].includes((_a = eventResponse.event) === null || _a === void 0 ? void 0 : _a.status);
    }
    isEVMEventConfirmed(eventResponse) {
        var _a;
        if (!eventResponse)
            return undefined;
        return ((_a = eventResponse.event) === null || _a === void 0 ? void 0 : _a.status) === types_2.Event_Status.STATUS_CONFIRMED;
    }
    isEVMEventCompleted(eventResponse) {
        var _a;
        if (!eventResponse)
            return undefined;
        return ((_a = eventResponse.event) === null || _a === void 0 ? void 0 : _a.status) === types_2.Event_Status.STATUS_COMPLETED;
    }
    getEvmEvent(srcChainId, destChainId, srcTxHash, evmWalletDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            let eventIndex = -1, success = false, errorMessage = "", infoLog = "";
            try {
                eventIndex = (yield this.getEventIndex(srcChainId, srcTxHash, evmWalletDetails));
            }
            catch (e) {
                return {
                    success,
                    errorMessage: `getEvmEvent(): could not find event index for ${srcTxHash}`,
                    commandId: "",
                    eventResponse: {},
                    infoLog,
                };
            }
            const commandId = this.getCidFromSrcTxHash(destChainId, srcTxHash, eventIndex);
            infoLog = `srcTxHash: ${srcTxHash}, generated commandId: ${commandId}`;
            const eventResponse = yield this.axelarQueryApi.getEVMEvent(srcChainId, srcTxHash, eventIndex);
            if (!eventResponse || this.isEVMEventFailed(eventResponse)) {
                errorMessage = this.isEVMEventFailed(eventResponse)
                    ? `getEvmEvent(): event on source chain is not successful for: ${srcTxHash}`
                    : `getEvmEvent(): could not determine status of event: ${srcTxHash}`;
                return {
                    success,
                    errorMessage,
                    commandId,
                    eventResponse: {},
                    infoLog,
                };
            }
            success = true;
            infoLog = `${srcTxHash} correspondes to command ID: ${commandId}`;
            return {
                commandId,
                eventResponse,
                success,
                errorMessage,
                infoLog,
            };
        });
    }
    findEventAndConfirmIfNeeded(srcChain, destChain, txHash, evmWalletDetails, sleepSeconds = 30) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = {
                confirmTx: null,
                success: true,
                errorMessage: "",
                infoLogs: [],
                commandId: "",
                eventResponse: null,
            };
            let confirmLog = "";
            if (this.debugMode)
                console.debug(`confirmation: checking whether ${txHash} needs to be confirmed on Axelar`);
            const evmEventResponse = yield this.getEvmEvent(srcChain, destChain, txHash, evmWalletDetails);
            res.commandId = evmEventResponse.commandId;
            res.eventResponse = evmEventResponse.eventResponse;
            const { infoLog: getEvmEventInfoLog } = evmEventResponse;
            if (this.debugMode)
                console.debug(`confirmation: ${getEvmEventInfoLog}`);
            if (this.isEVMEventCompleted(res.eventResponse) ||
                this.isEVMEventConfirmed(res.eventResponse)) {
                confirmLog = `confirmation: event for ${txHash} was already detected on the network and did not need to be confirmed`;
            }
            else {
                /**todo, need to check whether tx is finalized */
                // const confirmationHeight = await this.axelarQueryApi.getConfirmationHeight(srcChain);
                res.confirmTx = yield this.confirmGatewayTx(txHash, srcChain).catch((e) => {
                    console.error(e);
                    return null;
                });
                if (!res.confirmTx) {
                    res.success = false;
                    res.errorMessage = "findEventAndConfirmIfNeeded(): unable to confirm transaction on Axelar";
                    return res;
                }
                confirmLog = `confirmation: successfully confirmed ${txHash} on Axelar; waiting ${sleepSeconds} seconds for network confirmation`;
                if (this.debugMode)
                    console.debug(confirmLog);
                yield (0, utils_1.sleep)(sleepSeconds);
                const updatedEvent = yield this.getEvmEvent(srcChain, destChain, txHash, evmWalletDetails);
                if (this.isEVMEventCompleted(updatedEvent === null || updatedEvent === void 0 ? void 0 : updatedEvent.eventResponse)) {
                    res.eventResponse = updatedEvent.eventResponse;
                    confirmLog += `; confirmed event was finalized`;
                }
                else {
                    res.success = false;
                    res.errorMessage = `findEventAndConfirmIfNeeded(): could not confirm and finalize event successfully: ${txHash}`;
                    confirmLog += `; confirmed event was unable to be finalized`;
                }
            }
            if (this.debugMode)
                console.debug(confirmLog);
            getEvmEventInfoLog && res.infoLogs.push(getEvmEventInfoLog);
            res.infoLogs.push(confirmLog);
            return res;
        });
    }
    findBatchAndSignIfNeeded(commandId, destChainId, sleepSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            let signTxLog = "";
            const res = {
                success: true,
                errorMessage: "",
                signCommandTx: null,
                infoLogs: [],
            };
            if (this.debugMode)
                console.debug(`signing: checking whether command ID: ${commandId} needs to be signed`);
            try {
                const batchData = yield this.fetchBatchData(destChainId, commandId);
                if (batchData) {
                    signTxLog = `signing: batch data exists so do not need to sign. commandId: ${commandId}, batchId: ${batchData.batch_id}; waiting ${sleepSeconds} seconds to attempt broadcast`;
                }
                else {
                    res.signCommandTx = yield this.signCommands(destChainId);
                    signTxLog = `signing: signed batch for commandId (${commandId}) in tx: ${res.signCommandTx.transactionHash}; waiting ${sleepSeconds} seconds to attempt broadcast`;
                }
                if (this.debugMode)
                    console.debug(signTxLog);
                yield (0, utils_1.sleep)(sleepSeconds);
            }
            catch (e) {
                console.error(e);
                res.errorMessage = `findBatchAndSignIfNeeded(): issue retrieving and signing command data: ${commandId}`;
                res.success = false;
            }
            res.infoLogs.push(signTxLog);
            return res;
        });
    }
    findBatchAndBroadcast(commandId, destChainId, wallet, iter = 0, maxTries = 2) {
        return __awaiter(this, void 0, void 0, function* () {
            if (iter > maxTries)
                return {
                    success: false,
                    errorMessage: `findBatchAndBroadcast(): this recovery stalled out on waiting for signing. please try again later. `,
                    approveTx: null,
                    infoLogs: [],
                };
            if (this.debugMode)
                console.debug(`broadcasting: checking for command ID: ${commandId} to broadcast`);
            let broadcastTxLog = "";
            const res = {
                success: true,
                errorMessage: "",
                approveTx: null,
                infoLogs: [],
            };
            try {
                const batchData = yield this.fetchBatchData(destChainId, commandId);
                if (!batchData) {
                    res.success = false;
                    res.errorMessage = `findBatchAndBroadcast(): unable to retrieve batch data for ${commandId}`;
                    return res;
                }
                const commandData = batchData.command_ids.find((t) => t === commandId);
                if (!commandData) {
                    res.success = false;
                    res.errorMessage = `findBatchAndBroadcast(): unable to retrieve command ID (${commandId}) in batch data`;
                    return res;
                }
                switch (batchData.status) {
                    case "BATCHED_COMMANDS_STATUS_SIGNED":
                        res.approveTx = yield this.sendApproveTx(destChainId, batchData.execute_data, wallet);
                        broadcastTxLog = `broadcasting: batch ID ${batchData.batch_id} broadcasted to ${destChainId}`;
                        res.infoLogs.push(broadcastTxLog);
                        break;
                    case "BATCHED_COMMANDS_STATUS_SIGNING": {
                        broadcastTxLog = `broadcasting: batch ID ${batchData.batch_id} signing in process, checking again in 15 seconds`;
                        if (this.debugMode)
                            console.debug(broadcastTxLog);
                        res.infoLogs.push(broadcastTxLog);
                        (0, utils_1.sleep)(15);
                        const retry = yield this.findBatchAndBroadcast(commandId, destChainId, wallet, iter + 1, maxTries);
                        if (retry.infoLogs)
                            res.infoLogs = [...res.infoLogs, ...retry.infoLogs];
                        break;
                    }
                    default:
                        res.errorMessage = `findBatchAndBroadcastIfNeeded(): status unsuccessful for command data: ${commandId}`;
                        res.success = false;
                }
            }
            catch (e) {
                res.errorMessage = `findBatchAndBroadcastIfNeeded(): issue retrieving and broadcasting command data: ${commandId}`;
                res.success = false;
            }
            return res;
        });
    }
    manualRelayToDestChain(txHash, evmWalletDetails, escapeAfterConfirm = true) {
        return __awaiter(this, void 0, void 0, function* () {
            let confirmTx = null;
            let signCommandTx = null;
            let approveTx = null;
            const success = true;
            let infoLogs = [];
            const _evmWalletDetails = evmWalletDetails || { useWindowEthereum: true };
            const { callTx, status } = yield this.queryTransactionStatus(txHash);
            /**first check if transaction is already executed */
            if (exports.GMPErrorMap[status])
                return (0, exports.GMPErrorResponse)(exports.GMPErrorMap[status]);
            const srcChain = callTx.chain;
            const destChain = callTx.returnValues.destinationChain;
            let commandId = "";
            /**find event and confirm if needed */
            let confirmTxRequest;
            try {
                confirmTxRequest = yield this.findEventAndConfirmIfNeeded(srcChain, destChain, txHash, _evmWalletDetails);
                confirmTx = confirmTxRequest.confirmTx;
                commandId = confirmTxRequest.commandId;
                // eventResponse = confirmTxRequest.eventResponse;
                if (confirmTxRequest.infoLogs)
                    infoLogs = [...infoLogs, ...confirmTxRequest.infoLogs];
            }
            catch (e) {
                return (0, exports.GMPErrorResponse)(types_1.ApproveGatewayError.CONFIRM_COMMAND_FAILED, e.errorMessage);
            }
            if (!(confirmTxRequest === null || confirmTxRequest === void 0 ? void 0 : confirmTxRequest.success))
                return (0, exports.GMPErrorResponse)(types_1.ApproveGatewayError.ERROR_BATCHED_COMMAND, confirmTxRequest.errorMessage);
            else if (confirmTx && escapeAfterConfirm) {
                return {
                    success,
                    confirmTx,
                    infoLogs,
                };
            }
            /**find batch and sign if needed */
            let signTxRequest;
            try {
                signTxRequest = yield this.findBatchAndSignIfNeeded(commandId, destChain);
                signCommandTx = signTxRequest.signCommandTx;
                if (signTxRequest.infoLogs)
                    infoLogs = [...infoLogs, ...signTxRequest.infoLogs];
            }
            catch (e) {
                throw `error finding batch to sign, ${e}`;
            }
            if (!(signTxRequest === null || signTxRequest === void 0 ? void 0 : signTxRequest.success))
                return (0, exports.GMPErrorResponse)(types_1.ApproveGatewayError.SIGN_COMMAND_FAILED, signTxRequest.errorMessage);
            /**find batch and manually execute if needed */
            let broadcastTxRequest;
            try {
                broadcastTxRequest = yield this.findBatchAndBroadcast(commandId, destChain, _evmWalletDetails);
                approveTx = broadcastTxRequest.approveTx;
                if (broadcastTxRequest.infoLogs)
                    infoLogs = [...infoLogs, ...broadcastTxRequest.infoLogs];
            }
            catch (e) {
                throw `error finding batch to broadcast, ${e}`;
            }
            if (!(broadcastTxRequest === null || broadcastTxRequest === void 0 ? void 0 : broadcastTxRequest.success))
                return (0, exports.GMPErrorResponse)(types_1.ApproveGatewayError.ERROR_BROADCAST_EVENT, broadcastTxRequest.errorMessage);
            return {
                success,
                confirmTx,
                signCommandTx,
                approveTx,
                infoLogs,
            };
        });
    }
    /**
     * Check if given transaction is already executed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already executed
     */
    isExecuted(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txStatus = yield this.queryTransactionStatus(txHash).catch(() => undefined);
            return (txStatus === null || txStatus === void 0 ? void 0 : txStatus.status) === AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED;
        });
    }
    /**
     * Check if given transaction is already confirmed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already confirmed
     */
    isConfirmed(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txStatus = yield this.queryTransactionStatus(txHash).catch(() => undefined);
            return [AxelarRecoveryApi_1.GMPStatus.SRC_GATEWAY_CONFIRMED, AxelarRecoveryApi_1.GMPStatus.DEST_GATEWAY_APPROVED].includes(this.parseGMPStatus(txStatus === null || txStatus === void 0 ? void 0 : txStatus.status));
        });
    }
    /**
     * Calculate the gas fee in native token for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateNativeGasFee(txHash, sourceChain, destinationChain, gasTokenSymbol, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([sourceChain, destinationChain], this.environment);
            const provider = options.provider || (0, providerHelper_1.getDefaultProvider)(sourceChain, this.environment);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const paidGasFee = (0, contractEventHelper_1.getNativeGasAmountFromTxReceipt)(receipt) || "0";
            const hasTxBeenConfirmed = (yield this.isConfirmed(txHash)) || false;
            options.shouldSubtractBaseFee = hasTxBeenConfirmed;
            return this.subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options);
        });
    }
    /**
     * Calculate the gas fee in an ERC-20 tokens for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateGasFee(txHash, sourceChain, destinationChain, gasTokenSymbol, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_1.throwIfInvalidChainIds)([sourceChain, destinationChain], this.environment);
            const provider = options.provider || (0, providerHelper_1.getDefaultProvider)(sourceChain, this.environment);
            const receipt = yield provider.getTransactionReceipt(txHash);
            const paidGasFee = (0, contractEventHelper_1.getGasAmountFromTxReceipt)(receipt) || "0";
            return this.subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options);
        });
    }
    getEventIndex(chain, txHash, evmWalletDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.getSigner(chain, evmWalletDetails || { useWindowEthereum: true });
            const receipt = yield signer.provider.getTransactionReceipt(txHash);
            if (!receipt)
                return -1;
            const eventIndex = (0, contractEventHelper_1.getEventIndexFromTxReceipt)(receipt);
            return eventIndex;
        });
    }
    /**
     * Pay native token as gas fee for the given transaction hash.
     * If the transaction details is not valid, it will return an error with reason.
     * @param chain - source chain
     * @param txHash - transaction hash
     * @param options - options
     * @returns
     */
    addNativeGas(chain, txHash, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const evmWalletDetails = (options === null || options === void 0 ? void 0 : options.evmWalletDetails) || { useWindowEthereum: true };
            const signer = this.getSigner(chain, evmWalletDetails);
            const signerAddress = yield signer.getAddress();
            const gasReceiverAddress = yield this.axelarQueryApi.getContractAddressFromConfig(chain, "gas_service");
            const nativeGasTokenSymbol = contract_1.NATIVE_GAS_TOKEN_SYMBOL[chain];
            const receipt = yield signer.provider.getTransactionReceipt(txHash);
            if (!receipt)
                return (0, error_1.InvalidTransactionError)(chain);
            const destinationChain = (0, contractEventHelper_1.getDestinationChainFromTxReceipt)(receipt);
            const logIndex = (0, contractEventHelper_1.getLogIndexFromTxReceipt)(receipt);
            // Check if given txHash is valid
            if (!destinationChain)
                return (0, error_1.NotGMPTransactionError)();
            // Check if the transaction status is already executed or not.
            const _isExecuted = yield this.isExecuted(txHash);
            if (_isExecuted)
                return (0, error_1.AlreadyExecutedError)();
            let gasFeeToAdd = options === null || options === void 0 ? void 0 : options.amount;
            if (!gasFeeToAdd) {
                gasFeeToAdd = yield this.calculateNativeGasFee(txHash, chain, destinationChain, nativeGasTokenSymbol, {
                    estimatedGas: options === null || options === void 0 ? void 0 : options.estimatedGasUsed,
                    gasMultipler: options === null || options === void 0 ? void 0 : options.gasMultipler,
                    provider: evmWalletDetails.provider,
                }).catch(() => undefined);
            }
            // Check if gas price is queried successfully.
            if (!gasFeeToAdd)
                return (0, error_1.GasPriceAPIError)();
            // Check if gas fee is not already sufficiently paid.
            if (gasFeeToAdd === "0")
                return (0, error_1.AlreadyPaidGasFeeError)();
            const refundAddress = (options === null || options === void 0 ? void 0 : options.refundAddress) || signerAddress;
            const contract = new ethers_1.ethers.Contract(gasReceiverAddress, [
                "function addNativeGas(bytes32 txHash,uint256 logIndex,address refundAddress) external payable",
            ], signer);
            return contract
                .addNativeGas(txHash, logIndex, refundAddress, {
                value: gasFeeToAdd,
            })
                .then((tx) => tx.wait())
                .then((tx) => ({
                success: true,
                transaction: tx,
            }))
                .catch(error_1.ContractCallError);
        });
    }
    /**
     * Pay ERC20 token as gas fee for the given transaction hash.
     * If the transaction details or `gasTokenAddress` is not valid, it will return an error with reason.
     *
     * @param chain EvmChain - The source chain of the transaction hash.
     * @param txHash string - The transaction hash.
     * @param gasTokenAddress string - The address of the ERC20 token to pay as gas fee.
     * @param options AddGasOptions - The options to pay gas fee.
     * @returns
     */
    addGas(chain, txHash, gasTokenAddress, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const evmWalletDetails = (options === null || options === void 0 ? void 0 : options.evmWalletDetails) || { useWindowEthereum: true };
            const signer = this.getSigner(chain, evmWalletDetails);
            const signerAddress = yield signer.getAddress();
            const gasReceiverAddress = yield this.axelarQueryApi.getContractAddressFromConfig(chain, "gas_service");
            const gasTokenContract = new ethers_1.ethers.Contract(gasTokenAddress, erc20Abi_json_1.default, signer.provider);
            const gasTokenSymbol = yield gasTokenContract.symbol().catch(() => undefined);
            // Check if given `gasTokenAddress` exists
            if (!gasTokenSymbol)
                return (0, error_1.InvalidGasTokenError)();
            const axelarGateway = AxelarGateway_1.AxelarGateway.create(this.environment, chain, signer.provider);
            const gatewayGasTokenAddress = yield axelarGateway.getTokenAddress(gasTokenSymbol);
            // Check if given `gasTokenAddress` is supported by Axelar.
            if (gatewayGasTokenAddress === ethers_1.ethers.constants.AddressZero)
                return (0, error_1.UnsupportedGasTokenError)(gasTokenAddress);
            const receipt = yield signer.provider.getTransactionReceipt(txHash);
            // Check if transaction exists
            if (!receipt)
                return (0, error_1.InvalidTransactionError)(chain);
            const destinationChain = (0, contractEventHelper_1.getDestinationChainFromTxReceipt)(receipt);
            const logIndex = (0, contractEventHelper_1.getLogIndexFromTxReceipt)(receipt);
            // Check if given txHash is valid
            if (!destinationChain)
                return (0, error_1.NotGMPTransactionError)();
            // Check if the transaction status is already executed or not.
            const _isExecuted = yield this.isExecuted(txHash);
            if (_isExecuted)
                return (0, error_1.AlreadyExecutedError)();
            let gasFeeToAdd = options === null || options === void 0 ? void 0 : options.amount;
            if (!gasFeeToAdd) {
                gasFeeToAdd = yield this.calculateGasFee(txHash, chain, destinationChain, gasTokenSymbol, {
                    estimatedGas: options === null || options === void 0 ? void 0 : options.estimatedGasUsed,
                    provider: evmWalletDetails.provider,
                }).catch(() => undefined);
            }
            // Check if gas price is queried successfully.
            if (!gasFeeToAdd)
                return (0, error_1.GasPriceAPIError)();
            // Check if gas fee is not already sufficiently paid.
            if (gasFeeToAdd === "0")
                return (0, error_1.AlreadyPaidGasFeeError)();
            const refundAddress = (options === null || options === void 0 ? void 0 : options.refundAddress) || signerAddress;
            const contract = new ethers_1.ethers.Contract(gasReceiverAddress, new utils_2.Interface([
                "function addGas(bytes32 txHash,uint256 txIndex,address gasToken,uint256 gasFeeAmount,address refundAddress) external",
            ]), signer);
            return contract
                .addGas(txHash, logIndex, gasTokenAddress, gasFeeToAdd, refundAddress)
                .then((tx) => tx.wait())
                .then((tx) => ({
                success: true,
                transaction: tx,
            }))
                .catch(error_1.ContractCallError);
        });
    }
    /**
     * Execute a transaction on the destination chain associated with given `srcTxHash`.
     * @param srcTxHash - The transaction hash on the source chain.
     * @param srcTxLogIndex - The log index of the transaction on the source chain.
     * @param evmWalletDetails - The wallet details to use for executing the transaction.
     * @returns The result of executing the transaction.
     */
    execute(srcTxHash, srcTxLogIndex, evmWalletDetails) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryExecuteParams(srcTxHash, srcTxLogIndex).catch(() => undefined);
            // Couldn't query the transaction details
            if (!response)
                return (0, error_1.GMPQueryError)();
            // Already executed
            if ((response === null || response === void 0 ? void 0 : response.status) === AxelarRecoveryApi_1.GMPStatus.DEST_EXECUTED)
                return (0, error_1.AlreadyExecutedError)();
            // Not Approved yet
            if ((response === null || response === void 0 ? void 0 : response.status) !== AxelarRecoveryApi_1.GMPStatus.DEST_GATEWAY_APPROVED)
                return (0, error_1.NotApprovedError)();
            const executeParams = response.data;
            const gasLimitBuffer = (evmWalletDetails === null || evmWalletDetails === void 0 ? void 0 : evmWalletDetails.gasLimitBuffer) || 0;
            const { destinationChain, destinationContractAddress } = executeParams;
            const signer = this.getSigner(destinationChain, evmWalletDetails);
            const contract = new ethers_1.ethers.Contract(destinationContractAddress, IAxelarExecutable_1.default.abi, signer);
            const txResult = yield (0, helpers_1.callExecute)(executeParams, contract, gasLimitBuffer)
                .then((tx) => {
                const { commandId, sourceChain, sourceAddress, payload, symbol, amount, isContractCallWithToken, } = executeParams;
                const functionName = isContractCallWithToken ? "executeWithToken" : "execute";
                return {
                    success: true,
                    transaction: tx,
                    data: {
                        functionName,
                        args: {
                            commandId,
                            sourceChain,
                            sourceAddress,
                            payload,
                            symbol,
                            amount,
                        },
                    },
                };
            })
                .catch((e) => {
                if (e.message === helpers_1.CALL_EXECUTE_ERROR.INSUFFICIENT_FUNDS) {
                    return (0, error_1.InsufficientFundsError)(executeParams);
                }
                else if (e.message === helpers_1.CALL_EXECUTE_ERROR.REVERT) {
                    return (0, error_1.ExecutionRevertedError)(executeParams);
                }
                else {
                    // should not happen
                    return (0, error_1.ContractCallError)(e);
                }
            });
            // Submit execute data to axelarscan if the contract execution is success.
            const signerAddress = yield signer.getAddress();
            const executeTxHash = (_a = txResult.transaction) === null || _a === void 0 ? void 0 : _a.transactionHash;
            if (executeTxHash) {
                yield this.saveGMP(srcTxHash, signerAddress, executeTxHash).catch(() => undefined);
            }
            else {
                yield this.saveGMP(srcTxHash, signerAddress, "", txResult.error).catch(() => undefined);
            }
            return txResult;
        });
    }
    subtractGasFee(sourceChain, destinationChain, gasTokenSymbol, paidGasFee, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const totalGasFee = yield this.axelarQueryApi.estimateGasFee(sourceChain, destinationChain, gasTokenSymbol, options.estimatedGas, options.gasMultipler, undefined, undefined);
            let topupGasAmount = ethers_1.ethers.BigNumber.from(totalGasFee);
            if (options.shouldSubtractBaseFee) {
                const response = yield this.axelarQueryApi
                    .getNativeGasBaseFee(sourceChain, destinationChain, gasTokenSymbol)
                    .catch(() => undefined);
                if (response && response.baseFee) {
                    topupGasAmount = topupGasAmount.sub(response.baseFee);
                }
            }
            return topupGasAmount.gt(0) ? topupGasAmount.toString() : "0";
        });
    }
    getSigner(chain, evmWalletDetails = { useWindowEthereum: true }) {
        const { rpcMap, networkInfo } = chain_1.default[this.environment];
        const evmClientConfig = {
            rpcUrl: rpcMap[chain],
            networkOptions: networkInfo[chain],
            evmWalletDetails,
        };
        const evmClient = new EVMClient_1.default(evmClientConfig);
        return evmClient.getSigner();
    }
}
exports.AxelarGMPRecoveryAPI = AxelarGMPRecoveryAPI;
//# sourceMappingURL=AxelarGMPRecoveryAPI.js.map