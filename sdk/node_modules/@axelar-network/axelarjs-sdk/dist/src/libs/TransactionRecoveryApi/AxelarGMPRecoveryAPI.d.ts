import { AxelarRecoveryAPIConfig, EvmChain, EvmWalletDetails, AddGasOptions, GasToken, TxResult, QueryGasFeeOptions, ApproveGatewayError, ApproveGatewayResponse, AxelarTxResponse } from "../types";
import { AxelarRecoveryApi } from "./AxelarRecoveryApi";
import { AxelarQueryAPI } from "../AxelarQueryAPI";
import { EventResponse } from "@axelar-network/axelarjs-types/axelar/evm/v1beta1/query";
export declare const GMPErrorMap: Record<string, ApproveGatewayError>;
interface ConfirmTxSDKResponse {
    confirmTx: AxelarTxResponse | null;
    success: boolean;
    errorMessage: string;
    infoLogs: string[];
    commandId: string;
    eventResponse: EventResponse | null;
}
interface SignTxSDKResponse {
    success: boolean;
    errorMessage: string;
    signCommandTx: AxelarTxResponse | null;
    infoLogs: string[];
}
interface BroadcastTxSDKResponse {
    success: boolean;
    errorMessage: string;
    approveTx: AxelarTxResponse | null;
    infoLogs: string[];
}
export declare const GMPErrorResponse: (error: ApproveGatewayError, errorDetails?: string) => {
    success: boolean;
    error: string;
};
export declare class AxelarGMPRecoveryAPI extends AxelarRecoveryApi {
    axelarQueryApi: AxelarQueryAPI;
    constructor(config: AxelarRecoveryAPIConfig);
    private saveGMP;
    getCidFromSrcTxHash(destChainId: string, txHash: string, eventIndex: number): string;
    doesTxMeetConfirmHt(chain: string, currHeight: number): Promise<boolean | undefined>;
    isEVMEventFailed(eventResponse: EventResponse | undefined): boolean | undefined;
    isEVMEventConfirmed(eventResponse: EventResponse): boolean | undefined;
    isEVMEventCompleted(eventResponse: EventResponse): boolean | undefined;
    getEvmEvent(srcChainId: string, destChainId: string, srcTxHash: string, evmWalletDetails?: EvmWalletDetails): Promise<{
        commandId: string;
        eventResponse: EventResponse;
        success: boolean;
        errorMessage: string;
        infoLog: string;
    }>;
    findEventAndConfirmIfNeeded(srcChain: EvmChain, destChain: EvmChain, txHash: string, evmWalletDetails: EvmWalletDetails, sleepSeconds?: number): Promise<ConfirmTxSDKResponse>;
    findBatchAndSignIfNeeded(commandId: string, destChainId: string, sleepSeconds?: number): Promise<SignTxSDKResponse>;
    findBatchAndBroadcast(commandId: string, destChainId: string, wallet: EvmWalletDetails, iter?: number, maxTries?: number): Promise<BroadcastTxSDKResponse>;
    manualRelayToDestChain(txHash: string, evmWalletDetails?: EvmWalletDetails, escapeAfterConfirm?: boolean): Promise<ApproveGatewayResponse | null>;
    /**
     * Check if given transaction is already executed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already executed
     */
    isExecuted(txHash: string): Promise<boolean>;
    /**
     * Check if given transaction is already confirmed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already confirmed
     */
    isConfirmed(txHash: string): Promise<boolean>;
    /**
     * Calculate the gas fee in native token for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateNativeGasFee(txHash: string, sourceChain: string, destinationChain: string, gasTokenSymbol: GasToken | string, options: QueryGasFeeOptions): Promise<string>;
    /**
     * Calculate the gas fee in an ERC-20 tokens for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateGasFee(txHash: string, sourceChain: EvmChain, destinationChain: EvmChain, gasTokenSymbol: GasToken | string, options: QueryGasFeeOptions): Promise<string>;
    getEventIndex(chain: EvmChain, txHash: string, evmWalletDetails?: EvmWalletDetails): Promise<Nullable<number>>;
    /**
     * Pay native token as gas fee for the given transaction hash.
     * If the transaction details is not valid, it will return an error with reason.
     * @param chain - source chain
     * @param txHash - transaction hash
     * @param options - options
     * @returns
     */
    addNativeGas(chain: EvmChain, txHash: string, options?: AddGasOptions): Promise<TxResult>;
    /**
     * Pay ERC20 token as gas fee for the given transaction hash.
     * If the transaction details or `gasTokenAddress` is not valid, it will return an error with reason.
     *
     * @param chain EvmChain - The source chain of the transaction hash.
     * @param txHash string - The transaction hash.
     * @param gasTokenAddress string - The address of the ERC20 token to pay as gas fee.
     * @param options AddGasOptions - The options to pay gas fee.
     * @returns
     */
    addGas(chain: EvmChain, txHash: string, gasTokenAddress: string, options?: AddGasOptions): Promise<TxResult>;
    /**
     * Execute a transaction on the destination chain associated with given `srcTxHash`.
     * @param srcTxHash - The transaction hash on the source chain.
     * @param srcTxLogIndex - The log index of the transaction on the source chain.
     * @param evmWalletDetails - The wallet details to use for executing the transaction.
     * @returns The result of executing the transaction.
     */
    execute(srcTxHash: string, srcTxLogIndex?: number, evmWalletDetails?: EvmWalletDetails): Promise<TxResult>;
    private subtractGasFee;
    private getSigner;
}
export {};
//# sourceMappingURL=AxelarGMPRecoveryAPI.d.ts.map